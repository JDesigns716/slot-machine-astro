---
import TailwindIndicator from "../components/TailwindIndicator.astro";
import "../styles/global.css";
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <title>Slot Machine</title>
  </head>
  <body
    class="min-h-dvh flex items-center justify-center bg-[#0b0b1f] bg-[radial-gradient(120%_80%_at_50%_20%,rgba(255,215,0,0.18)_0%,rgba(255,69,0,0.12)_25%,rgba(255,20,147,0.12)_45%,rgba(0,206,209,0.12)_65%,rgba(50,205,50,0.14)_80%,transparent_85%),radial-gradient(100%_100%_at_50%_120%,rgba(255,215,0,0.08)_0%,transparent_60%)] text-white antialiased"
  >
    <main class="max-w-3xl mx-auto p-6 sm:p-8">
      <h1 class="text-center sm:text-5xl text-2xl font-semibold mb-4">
        <span class="animate-[siren_1s_infinite]">🎰</span>
        <span
          class="font-['Audiowide'] bg-clip-text text-transparent bg-[linear-gradient(90deg,#FFD700,#FF4500,#FF1493,#00CED1,#32CD32,#FFD700)] [background-size:200%_200%] animate-[rainbow_6s_linear_infinite]"
        >
          Jay's Slot Machine
        </span>
        <span class="animate-[siren_1s_infinite]">🎰</span>
      </h1>
      <div
        class="w-full mx-auto p-6 rounded-2xl shadow-lg bg-white/70 dark:bg-zinc-900/60 backdrop-blur border border-zinc-200/70 dark:border-zinc-800 select-none"
        data-slot
        data-start-balance="100"
        data-pair-mult="2"
        data-jackpot-mult="10"
        data-spin-ms="350"
        data-auto-interval="2000"
        data-persist-key="slot-machine.v1"
      >
        <div class="grid grid-cols-2 sm:grid-cols-3 gap-3 text-sm" data-hud>
          <div
            class="rounded-lg border border-zinc-200 dark:border-zinc-800 p-3 bg-white dark:bg-zinc-950"
          >
            <div
              class="font-['VT323'] text-xl font-bold text-zinc-500 text-center"
            >
              Balance
            </div>
            <div
              class="font-['Audiowide'] text-lg text-center font-semibold text-zinc-700 dark:text-zinc-100"
              data-balance
            >
              $ 100
            </div>
          </div>
          <div
            class="rounded-lg border border-zinc-200 dark:border-zinc-800 p-3 bg-white dark:bg-zinc-950"
          >
            <div
              class="font-['VT323'] text-xl font-bold text-zinc-500 text-center"
            >
              Bet
            </div>
            <div class="flex items-center justify-center gap-2">
              <button
                type="button"
                class="font-['Audiowide'] text-zinc-200 px-2 py-1 rounded-lg border border-zinc-300/70 dark:border-zinc-700 hover:bg-zinc-100 dark:hover:bg-zinc-800"
                data-bet-dec>-</button
              >
              <input
                type="number"
                min="1"
                max="50"
                value="5"
                class="font-['Audiowide'] text-zinc-200 w-16 px-2 py-1 rounded-lg border border-zinc-300/70 dark:border-zinc-700 bg-transparent text-center [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                data-bet
              />
              <button
                type="button"
                class="font-['Audiowide'] font-semibold text-zinc-200 px-2 py-1 rounded-lg border border-zinc-300/70 dark:border-zinc-700 hover:bg-zinc-100 dark:hover:bg-zinc-800"
                data-bet-inc>+</button
              >
            </div>
          </div>
          <div
            class="rounded-lg border border-zinc-200 dark:border-zinc-800 p-3 bg-white dark:bg-zinc-950"
          >
            <div
              class="font-['VT323'] text-xl font-bold text-zinc-500 text-center"
            >
              Plays
            </div>
            <div
              class="font-['Audiowide'] text-lg text-center font-semibold text-zinc-700 dark:text-zinc-100"
              data-plays
            >
              0
            </div>
          </div>
          <div
            class="rounded-lg border border-zinc-200 dark:border-zinc-800 p-3 bg-white dark:bg-zinc-950"
          >
            <div
              class="font-['VT323'] text-xl font-bold text-zinc-500 text-center"
            >
              2‑of‑a‑kind
            </div>
            <div
              class="font-['Audiowide'] text-lg text-center font-semibold text-zinc-700 dark:text-zinc-100"
              data-wins2
            >
              0
            </div>
          </div>
          <div
            class="rounded-lg border border-zinc-200 dark:border-zinc-800 p-3 bg-white dark:bg-zinc-950"
          >
            <div
              class="font-['VT323'] text-xl font-bold text-zinc-500 text-center"
            >
              3‑of‑a‑kind
            </div>
            <div
              class="font-['Audiowide'] text-lg text-center font-semibold text-zinc-700 dark:text-zinc-100"
              data-wins3
            >
              0
            </div>
          </div>
          <div
            class="rounded-lg border border-zinc-200 dark:border-zinc-800 p-3 bg-white dark:bg-zinc-950"
          >
            <div
              class="font-['VT323'] text-xl font-bold text-zinc-500 text-center"
            >
              Profit
            </div>
            <div
              class="font-['Audiowide'] text-lg text-center font-semibold transition-colors"
              data-profit
            >
              +$ 0
            </div>
          </div>
          <div
            class="font-['Audiowide'] col-span-full text-zinc-700 dark:text-zinc-300 text-center mt-2"
          >
            Win rate: <span data-winrate>0.0%</span> · RTP: <span data-rtp
              >0.0%</span
            >
          </div>
        </div>

        <!-- Reels -->
        <div
          class="grid grid-cols-3 gap-3 items-center justify-center text-5xl sm:text-6xl mt-6"
          aria-live="polite"
          aria-atomic="true"
          data-reels
        >
          <div
            class="flex items-center justify-center h-24 sm:h-28 rounded-xl bg-zinc-950/50 border border-zinc-200 dark:border-zinc-800 shadow-sm transition-transform"
            data-reel
          >
            <span data-symbol class="font-['VT323'] text-white">❔</span>
          </div>
          <div
            class="flex items-center justify-center h-24 sm:h-28 rounded-xl bg-zinc-950/50 border border-zinc-200 dark:border-zinc-800 shadow-sm transition-transform"
            data-reel
          >
            <span data-symbol class="font-['VT323'] text-white">❔</span>
          </div>
          <div
            class="flex items-center justify-center h-24 sm:h-28 rounded-xl bg-zinc-950/50 border border-zinc-200 dark:border-zinc-800 shadow-sm transition-transform"
            data-reel
          >
            <span data-symbol class="text-white font-['VT323']">❔</span>
          </div>
        </div>

        <!-- Controls -->
        <div
          class="flex flex-wrap items-center justify-center gap-3 mt-6"
          data-controls
        >
          <button
            type="button"
            class="font-['Audiowide'] inline-flex items-center gap-2 px-5 py-2.5 rounded-xl bg-emerald-600 text-white font-medium hover:brightness-110 active:scale-[0.98] disabled:opacity-60 disabled:cursor-not-allowed"
            data-spin>Spin</button
          >
          <button
            type="button"
            class="font-['Audiowide'] inline-flex items-center gap-2 px-4 py-2 rounded-xl border border-zinc-300/70 dark:border-zinc-700 hover:bg-zinc-100 dark:hover:bg-zinc-800 text-zinc-800 hover:text-zinc-900 dark:text-zinc-300 dark:hover:text-white"
            data-auto>Autoplay</button
          >
          <button
            type="button"
            class="font-['Audiowide'] inline-flex items-center gap-2 px-4 py-2 rounded-xl border border-zinc-300/70 dark:border-zinc-700 hover:bg-zinc-100 dark:hover:bg-zinc-800 text-zinc-800 hover:text-zinc-900 dark:text-zinc-300 dark:hover:text-white"
            data-reset>Reset</button
          >
          <button
            type="button"
            class="font-['Audiowide'] inline-flex items-center gap-2 px-4 py-2 rounded-xl border border-zinc-300/70 dark:border-zinc-700 hover:bg-zinc-100 dark:hover:bg-zinc-800 text-zinc-800 hover:text-zinc-900 dark:text-zinc-300 dark:hover:text-white"
            data-audio-toggle>🔊 Sound On</button
          >
        </div>

        <!-- Payouts -->
        <div
          class="font-['Audiowide'] text-center mt-4 text-sm text-zinc-700 dark:text-zinc-300"
        >
          Payouts — 3 match: <strong data-jackpotx>10× bet</strong> · 2 match: <strong
            data-pairx>2× bet</strong
          >
        </div>
      </div>
      <footer class="text-center font-['Audiowide'] mt-8 text-sm text-zinc-200">
        Copyright &copy; 2025 JDesigns All Rights Reserved
      </footer>
    </main>
    <TailwindIndicator />
    <script>
      const SYMBOLS = ["🍒", "🍋", "🔔", "💎", "𝟕", "🍀"];
      const MIN_BET = 1;
      const MAX_BET = 50;

      /**
       * Queries a single descendant element and returns it with the desired type.
       * @template T
       * @param {ParentNode} el - Root element to search within.
       * @param {string} sel - CSS selector to match.
       * @returns {T | null} Matching element or null when absent.
       */
      const q = <T extends Element = HTMLElement>(
        el: ParentNode,
        sel: string
      ): T | null => el.querySelector<T>(sel);

      /**
       * Queries all matching descendants and returns them as a typed array.
       * @template T
       * @param {ParentNode} el - Root element to search within.
       * @param {string} sel - CSS selector to match.
       * @returns {T[]} Array of matching elements.
       */
      const qa = <T extends Element = HTMLElement>(
        el: ParentNode,
        sel: string
      ): T[] => Array.from(el.querySelectorAll<T>(sel));

      /**
       * Restricts a number to stay within the provided lower and upper bounds.
       * @param {number} n - Value to clamp.
       * @param {number} lo - Minimum allowed value.
       * @param {number} hi - Maximum allowed value.
       * @returns {number} Clamped value.
       */
      const clamp = (n: number, lo: number, hi: number): number =>
        Math.min(hi, Math.max(lo, n));

      /**
       * Formats a percentage value to a single decimal place, falling back to 0.0% when invalid.
       * @param {number} n - Percentage (e.g. 42.5 for 42.5%).
       * @returns {string} Human-readable percentage string.
       */
      const pct = (n: number): string =>
        Number.isFinite(n) ? n.toFixed(1) + "%" : "0.0%";

      /**
       * Formats a number as signed currency without decimal precision.
       * @param {number} n - Amount to format.
       * @returns {string} Formatted currency string.
       */
      const fmtMoney = (n: number): string => {
        const sign = n >= 0 ? "+" : "-";
        return `${sign}$ ${Math.abs(n)}`;
      };

      /**
       * Applies a special highlight colour to the 𝟕 symbol.
       * @param {string} symbol - Symbol displayed on the reel.
       * @returns {string} Tailwind text colour class name.
       */
      const getColor = (symbol: string): string =>
        symbol === "𝟕" ? "text-red-500" : "text-white";

      /**
       * Handles serialization of game state in localStorage.
       */
      const persist = {
        /**
         * Restores persisted slot machine state.
         * @param {string} key - Storage key.
         * @returns {State | null} Stored state when available.
         */
        load(key: string): State | null {
          try {
            const s = localStorage.getItem(key);
            return s ? (JSON.parse(s) as State) : null;
          } catch {
            return null;
          }
        },
        /**
         * Saves the current slot machine state.
         * @param {string} key - Storage key.
         * @param {State} state - State snapshot to persist.
         */
        save(key: string, state: State): void {
          try {
            localStorage.setItem(key, JSON.stringify(state));
          } catch {}
        },
        /**
         * Removes any stored state for a fresh start.
         * @param {string} key - Storage key.
         */
        clear(key: string): void {
          try {
            localStorage.removeItem(key);
          } catch {}
        },
      };

      let AC: AudioContext | null = null;
      /**
       * Lazily creates (or returns) the shared AudioContext instance.
       * @returns {AudioContext} Browser audio context used for sound effects.
       */
      const ensureAC = (): AudioContext =>
        (AC ||= new ((window as any).AudioContext ||
          (window as any).webkitAudioContext)());
      /**
       * Plays a short tone using Web Audio for feedback cues.
       * @param {number} [f=440] - Frequency in Hertz.
       * @param {number} [d=0.1] - Duration in seconds.
       * @param {OscillatorType} [type="sine"] - Oscillator waveform.
       * @param {number} [gain=0.05] - Output gain value.
       */
      const tone = (
        f: number = 440,
        d: number = 0.1,
        type: OscillatorType = "sine",
        gain: number = 0.05
      ): void => {
        try {
          const c = ensureAC();
          const o = c.createOscillator();
          const g = c.createGain();
          o.type = type;
          o.frequency.value = f;
          g.gain.value = gain;
          o.connect(g);
          g.connect(c.destination);
          o.start();
          o.stop(c.currentTime + d);
        } catch {}
      };
      /**
       * Lightweight collection of sound effects for different outcomes.
       */
      const sfx: { spin: () => void; pair: () => void; jackpot: () => void } = {
        spin: () => tone(320, 0.08, "triangle", 0.04),
        pair: () => {
          tone(740, 0.12, "sine", 0.06);
          setTimeout(() => tone(880, 0.1, "sine", 0.06), 80);
        },
        jackpot: () => {
          tone(523.25, 0.15, "square", 0.07);
          setTimeout(() => tone(659.25, 0.18, "square", 0.07), 120);
          setTimeout(() => tone(783.99, 0.2, "square", 0.07), 240);
        },
      };

      /**
       * Randomly picks three symbols to simulate a slot machine spin.
       * @returns {SpinResult} Selected symbols for each reel.
       */
      const spin = (): SpinResult => {
        const pick = () => SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)];
        return { r1: pick(), r2: pick(), r3: pick() };
      };
      /**
       * Determines win conditions from a spin result.
       * @param {SpinResult} param0 - Reel symbols to evaluate.
       * @returns {{ allMatch: boolean; twoMatch: boolean }} Flags for jackpot and pair wins.
       */
      const evaluate = ({
        r1,
        r2,
        r3,
      }: SpinResult): { allMatch: boolean; twoMatch: boolean } => {
        const allMatch = r1 === r2 && r2 === r3;
        const twoMatch = !allMatch && (r1 === r2 || r1 === r3 || r2 === r3);
        return { allMatch, twoMatch };
      };

      type State = {
        balance: number;
        bet: number;
        plays: number;
        wins2: number;
        wins3: number;
        profit: number;
      };

      type SpinResult = { r1: string; r2: string; r3: string };

      /**
       * Bootstraps a slot machine instance by wiring up state, UI, and events.
       * @param {HTMLElement} root - Root element containing slot machine markup.
       */
      function init(root: HTMLElement): void {
        const ds = root.dataset;
        const cfg = {
          startBalance: Number(ds.startBalance ?? 100),
          pairMult: Number(ds.pairMult ?? 2),
          jackpotMult: Number(ds.jackpotMult ?? 10),
          spinMs: Number(ds.spinMs ?? 350),
          autoInterval: Number(ds.autoInterval ?? 500),
          persistKey: String(ds.persistKey ?? "slot-machine.v1"),
        };

        let state: State = {
          balance: cfg.startBalance,
          bet: clamp(
            Number(q<HTMLInputElement>(root, "[data-bet]")?.value ?? 5),
            MIN_BET,
            MAX_BET
          ),
          plays: 0,
          wins2: 0,
          wins3: 0,
          profit: 0,
        };
        const persisted = persist.load(cfg.persistKey);
        if (persisted) state = { ...state, ...persisted };

        const reels = qa<HTMLElement>(root, "[data-reel]");
        const symbols = reels.map((r) =>
          q<HTMLSpanElement>(r, "[data-symbol]")
        );
        const balanceEl = q<HTMLElement>(root, "[data-balance]");
        const playsEl = q<HTMLElement>(root, "[data-plays]");
        const wins2El = q<HTMLElement>(root, "[data-wins2]");
        const wins3El = q<HTMLElement>(root, "[data-wins3]");
        const profitEl = q<HTMLElement>(root, "[data-profit]");
        const winrateEl = q<HTMLElement>(root, "[data-winrate]");
        const rtpEl = q<HTMLElement>(root, "[data-rtp]");
        const betEl = q<HTMLInputElement>(root, "[data-bet]");
        const betInc = q<HTMLButtonElement>(root, "[data-bet-inc]");
        const betDec = q<HTMLButtonElement>(root, "[data-bet-dec]");
        const spinBtn = q<HTMLButtonElement>(root, "[data-spin]");
        const autoBtn = q<HTMLButtonElement>(root, "[data-auto]");
        const resetBtn = q<HTMLButtonElement>(root, "[data-reset]");
        const audioBtn = q<HTMLButtonElement>(root, "[data-audio-toggle]");
        const pairx = q<HTMLElement>(root, "[data-pairx]");
        const jackpotx = q<HTMLElement>(root, "[data-jackpotx]");

        if (pairx) pairx.textContent = `${cfg.pairMult}× bet`;
        if (jackpotx) jackpotx.textContent = `${cfg.jackpotMult}× bet`;

        let audioOn: boolean = true;
        let autoTimer: number | null = null;

        /**
         * Refreshes HUD values, derived metrics, and disables Spin when funds are insufficient.
         */
        function updateHUD(): void {
          balanceEl && (balanceEl.textContent = "$ " + String(state.balance));
          playsEl && (playsEl.textContent = String(state.plays));
          wins2El && (wins2El.textContent = String(state.wins2));
          wins3El && (wins3El.textContent = String(state.wins3));
          if (profitEl) {
            profitEl.textContent = fmtMoney(state.profit);
            profitEl.classList.remove(
              "text-emerald-500",
              "text-red-500",
              "text-zinc-700"
            );
            if (state.profit > 0) {
              profitEl.classList.add("text-emerald-500");
            } else if (state.profit < 0) {
              profitEl.classList.add("text-red-500");
            } else {
              profitEl.classList.add("text-zinc-700");
            }
          }
          if (betEl) betEl.value = String(state.bet);

          const wins = state.wins2 + state.wins3;
          const creditsIn = state.plays * state.bet;
          const creditsOut = state.profit + creditsIn;
          winrateEl &&
            (winrateEl.textContent = pct(
              state.plays ? (wins / state.plays) * 100 : 0
            ));
          rtpEl &&
            (rtpEl.textContent = pct(
              creditsIn ? (creditsOut / creditsIn) * 100 : 0
            ));
          // Disable Spin button if funds are insufficient
          spinBtn && (spinBtn.disabled = state.balance < state.bet);
        }

        /**
         * Updates reel symbols and applies styling per symbol.
         * @param {string[]} vals - Symbols to display on each reel.
         */
        function setSymbols(vals: string[]): void {
          vals.forEach((sym, i) => {
            const span = symbols[i];
            if (!span) return;
            span.textContent = sym;
            span.className = getColor(sym);
          });
        }

        /**
         * Briefly animates the reels to mimic physical movement.
         */
        function animate(): void {
          const ms = cfg.spinMs;
          reels.forEach((r, i) => {
            r.style.transform = "translateY(-6px)";
            setTimeout(() => {
              r.style.transform = "translateY(0)";
            }, ms);
          });
        }

        /**
         * Enables or disables primary controls as a group.
         * @param {boolean} disabled - Whether controls should be disabled.
         */
        function setControls(disabled: boolean): void {
          [spinBtn, autoBtn, resetBtn, betEl, betInc, betDec].forEach((el) => {
            if (el && "disabled" in el) el.disabled = disabled;
          });
        }

        /**
         * Runs a single spin, updates the state, triggers sounds, and persists changes.
         */
        function doSpin(): void {
          if (state.balance < state.bet) {
            updateHUD();
            return;
          }
          setControls(true);
          animate();
          if (audioOn) sfx.spin();

          const res = spin();
          setTimeout(() => {
            setSymbols([res.r1, res.r2, res.r3]);

            const { allMatch, twoMatch } = evaluate(res);
            const win = allMatch
              ? cfg.jackpotMult * state.bet
              : twoMatch
                ? cfg.pairMult * state.bet
                : 0;

            const net = win - state.bet;
            state.balance += net;
            state.profit += net;
            state.plays += 1;
            if (allMatch) {
              state.wins3 += 1;
              audioOn && sfx.jackpot();
            } else if (twoMatch) {
              state.wins2 += 1;
              audioOn && sfx.pair();
            }

            persist.save(cfg.persistKey, state);
            updateHUD();
            setControls(false);
          }, cfg.spinMs);
        }

        if (spinBtn) {
          spinBtn.onclick = () => doSpin();
        }

        if (autoBtn) {
          autoBtn.onclick = () => {
            if (autoTimer) {
              window.clearInterval(autoTimer);
              autoTimer = null;
              autoBtn.textContent = "Autoplay";
              autoBtn.setAttribute("aria-pressed", "false");
              setControls(false);
            } else {
              autoBtn.textContent = "Stop Auto";
              autoBtn.setAttribute("aria-pressed", "true");
              setControls(false);
              autoTimer = window.setInterval(() => {
                if (state.balance < state.bet) {
                  window.clearInterval(autoTimer!);
                  autoTimer = null;
                  autoBtn.textContent = "Autoplay";
                  autoBtn.setAttribute("aria-pressed", "false");
                  setControls(false);
                  return;
                }
                doSpin();
              }, cfg.autoInterval);
            }
          };
        }

        if (resetBtn) {
          resetBtn.onclick = () => {
            persist.clear(cfg.persistKey);
            state = {
              balance: cfg.startBalance,
              bet: clamp(state.bet, MIN_BET, MAX_BET),
              plays: 0,
              wins2: 0,
              wins3: 0,
              profit: 0,
            };
            setSymbols(["❔", "❔", "❔"]);
            updateHUD();
          };
        }

        if (audioBtn) {
          audioBtn.onclick = () => {
            audioOn = !audioOn;
            audioBtn.textContent = audioOn ? "🔊 Sound On" : "🔇 Sound Off";
          };
        }

        betEl &&
          (betEl.oninput = () => {
            const v = clamp(
              parseInt(betEl.value || "0", 10) || MIN_BET,
              MIN_BET,
              MAX_BET
            );
            state.bet = v;
            betEl.value = String(v);
            updateHUD();
          });
        betInc &&
          (betInc.onclick = () => {
            state.bet = clamp(state.bet + 1, MIN_BET, MAX_BET);
            updateHUD();
          });
        betDec &&
          (betDec.onclick = () => {
            state.bet = clamp(state.bet - 1, MIN_BET, MAX_BET);
            updateHUD();
          });

        updateHUD();
      }

      document
        .querySelectorAll<HTMLElement>("[data-slot]")
        .forEach((root) => init(root));
    </script>
  </body>
</html>
